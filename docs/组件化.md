# 组件化
组件是 vue 的核心之一，是对 DOM 的抽象，你想定义什么样的页面结构或 DOM，只要定义为组件，通过组件在页面上渲染出来
组件是一个 js 对象，它包含了组件的基础配置、render 等属性，用来描述出抽象的页面
vue 对组件的处理必定要考虑以下几个方面：
- 通过组件的描述对象创建出组件实例
- 处理组件的状态
- 在组件的各个生命周期处理对应配置
- 处理组件配置的模版，生成 vnode 再生成 DOM
- 组件是可以嵌套的，处理多级组件的关系
- 组件是会更新的，处理更新后组件的状态

接下来一一讲解 vue 对组件的处理


## vnode
vue 在将 dom 渲染出来之前，使用 虚拟 DOM 描述他们，vnode 是一个js对象，他有很多属性，都是为了描述对应的 DOM 而存在
在源码里，通过`_createVNode`方法创建 vnode，他接受几个参数，包括：`type props children`等，其他参数不是核心参数，暂时先不考虑
在这个方法中，首先处理`type`，再处理`props`上的样式相关属性
然后调用`createBaseVNode`创建 vnode
这个方法接收几乎同样的参数，然后生成一个 `vNode`对象实例
接着处理`children`，最后返回该 vnode 对象实例


## 模版编译
与 vue2 类似，vue3 的编译也分为3个阶段
- ast
- transform
- codegen

## 组件render函数
在开发时，我们通常使用`.vue` or `.tsx`文件来定义组件，在`.vue`文件里，组件的模版部分是`<template>`标签部分的内容，而`tsx`文件中，我们一般通过`jsx`语法直接写`render`函数
但无论是哪种方式，都将编译成通过 vue API 实现的`render`函数
如果我们检查打包工具的打包结果，会发现，所有组件的`render`都会在 build 阶段生成，那么在项目代码运行时就不用去编译了，只需使用`runtime-only`版本
如下是一个组件的定义和编译结果：
```js
import { defineComponent } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { menus } from './config'
import styles from './styles.module.less'
export default defineComponent({
  props: [],
  components: {},
  setup(props) {
    const route = useRoute()
    const router = useRouter()

    const goto = (menu: any) => {
      router.push({ name: menu.routeName })
    }

    return () => (
      <div class={styles.main}>
        {menus.map((menu) => (
          <div
            class={`${styles.menuItem} ${
              route.name === menu.routeName ? styles.menuItemActive : ''
            }`}
            onClick={() => goto(menu)}
          >
            {menu.label}
          </div>
        ))}
      </div>
    )
  },
})


import { a as defineComponent, u as useRoute, b as useRouter, c as createVNode, r as resolveComponent } from "./index-a4f8e459.js";
const menus = [
  {
    routeName: "modelList",
    label: "模型列表"
  },
  {
    routeName: "modelEvaluate",
    label: "模型评价"
  }
];
const main = "_main_16qsj_1";
const menuItem = "_menuItem_16qsj_6";
const menuItemActive = "_menuItemActive_16qsj_13";
const styles = {
  main,
  menuItem,
  menuItemActive
};
const SideMenu = /* @__PURE__ */ defineComponent({
  props: [],
  components: {},
  setup(props) {
    const route = useRoute();
    const router = useRouter();
    const goto = (menu) => {
      router.push({
        name: menu.routeName
      });
    };
    return () => createVNode("div", {
      "class": styles.main
    }, [menus.map((menu) => createVNode("div", {
      "class": `${styles.menuItem} ${route.name === menu.routeName ? styles.menuItemActive : ""}`,
      "onClick": () => goto(menu)
    }, [menu.label]))]);
  }
});
```
可以看到，组件的`render`就是一个生成`vNode`的函数嵌套（根据组件模版），这是`jsx`的编译，通过插件实现，`template`是怎么实现的呢？
```js
<template>
    <div class={styles.main}>
        <div 
          v-for="menu in menus" 
          :class="styles.menuItem + (route.name===menu.routeName ? styles.menuItemActive : '') " 
          @click="()=> goto(menu)"
        >
          {{ menu.label }} aaaa
        </div>
    </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { menus } from './config'
import styles from './styles.module.less'
export default defineComponent({
    props: [],
    components: {},
    setup() {
        const route = useRoute()
        const router = useRouter()

        const goto = (menu: any) => {
            router.push({ name: menu.routeName })
        }

        return {
            route,
            goto,
            menus,
            styles
        }
    }
})
</script>


const _sfc_main = defineComponent({
  props: [],
  components: {},
  setup() {
    const route = useRoute();
    const router = useRouter();
    const goto = (menu) => {
      router.push({ name: menu.routeName });
    };
    return {
      route,
      goto,
      menus,
      styles: styles$2
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1 = { class: "{styles.main}" };
const _hoisted_2 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(
    "div",
    _hoisted_1,
    [
      (
        openBlock(true),
        createElementBlock(
          Fragment,
          null,
          renderList(
            _ctx.menus,
            (menu) => {
              return openBlock(), createElementBlock(
                "div",
                {
                  class: normalizeClass(_ctx.styles.menuItem + (_ctx.route.name === menu.routeName ? _ctx.styles.menuItemActive : "")),
                  onClick: () => _ctx.goto(menu)
                },
                toDisplayString(menu.label) + " aaaa ",
                11,
                _hoisted_2
              );
            }
          ),
          256
        )
      )
    ]
  );
}
const sideMenu = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
```

这是相同的组件，只不过使用了 vue3 提供的 编译器进行编译，但是我们可以发现他与上一个编译结果有明显的区别，这个`render`函数中的`vNode`好像是与`block`有关，而不是单纯的`createVNode`，那么这个`block`是什么呢？其实这是 vue3 中对虚拟节点

## 组件渲染
之前介绍过，在渲染时，使用的都是 vnode，我们在开发时肯定使用了组件，那么碰到 vnode 中有组件时会怎么处理呢
一般这部分处理都是在`patch`阶段
`patch`会根据 vnode 的 `type` 来区分普通元素、组件、内部组件、注释等，然后使用对应的手段处理他们
这一节我们只考虑组件的情况
对组件的处理通过`processComponent`实现，该函数中定义了初次渲染和更新时的处理，先看初次渲染
通过`mountComponent`方法挂载组件
首先获取组件实例，通过`createComponentInstance`创建组件实例，他的功能很简单，就是生成一个包含组件配置的一个对象实例，并返回该对象实例，其中组件实例的属性很多，但我们只要知道哪些功能对应哪些属性就比较好理解
接着调用`setupComponent`来设置`props solts`等属性，对于参数和插槽的处理在之后的章节介绍
同时在这个函数内还会调用组件的`setup`，一般他的返回值就是组件的`render`，这样就获得了组件的`render`

此时关于组件的所有静态的配置都已完成，接着就要处理组件渲染了，也就是对`render`的处理
`setupRenderEffect`函数基于组件实例创建一个 effect 来更新组件的内容
这个`effect`的`run`是`componentUpdateFn`，`scheduler`是`effect.run`

`componentUpdateFn`函数会针对组件的初次挂载和更新进行不同处理，先看初次挂载
会处理生命周期钩子
调用`renderComponentRoot`函数获取组件实例的`subTree`
`subTree`与`vNode`的区别是，vnode只是组件实例这一级的描述，而 subTree 是组件 render 结果的描述，包括 children 属性
拿到`subTree`后，调用`patch`，将`subTree`的内容继续渲染
通过递归调用`patch`最终将所有的组件都解析完毕，得到浏览器能渲染的原始标签结构，`patch`同样有一个分支会处理这些原始标签，将他们生成真正的 DOM，然后插入到页面上

<img src="./imgs/组件渲染.drawio.png" />

## 组件更新

### diff